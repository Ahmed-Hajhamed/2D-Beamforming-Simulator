from PyQt5.QtWidgets import (
    QApplication, QMainWindow)
from qt_material import apply_stylesheet
import sys
import numpy as np
from  PhasedArray import PhasedArray
from Receiver import Receiver
from matplotlib.animation import FuncAnimation
import my_ui

class Main(QMainWindow, my_ui.ui):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.receivers_ = {}
        self.arrays = {}
        self.distances = None
        x = np.linspace(-20, 20, 200)
        y = np.linspace( -20, 20, 200)
        self.meshgrid = np.meshgrid(x, y) 
        self.save_button.clicked.connect(self.add_update_array)
        # self.button_of_add_new_array.clicked.connect()
        self.button_of_add_new_reciver.clicked.connect(self.add_update_receiver)
        self.remove_array_button.clicked.connect(self.remove_array)
        self.remove_button_of_reciver.clicked.connect(self.remove_receiver)
        self.current_arrays_combo_box.currentTextChanged.connect(self.change_current_array)
        self.current_recivers_combo_box.currentTextChanged.connect(self.change_current_receiver)
        self.beam_profile_x = np.linspace(-20, 20, 500)
        self.beam_profile_y = np.zeros_like(self.beam_profile_x)
        self.beam_profile_angles = np.linspace(0, 2 * np.pi, 360)
        self.beam_profile_power = np.zeros_like(self.beam_profile_angles)
        self.current_array = None
        self.current_receiver = None
        self.receiver_texts = []

    def add_update_array(self):
        name = self.array_name_line_edit.text()
        number_of_elements = self.slider_of_transmiters_number.value()
        frequencies_text = self.frequencies_line_edit.text()
        frequencies_text = frequencies_text.split(",")
        frequencies = []

        for i in range (len(frequencies_text)):
            frequencies.append(int(frequencies_text[i]))

        steering_angle = self.slider_of_steering_angle.value()
        position = np.array([int(self.array_position_x_line_edit.text()), int(self.array_position_y_line_edit.text())])

        if self.radio_button_of_linear.isChecked():
            array_type = "Linear"
            elements_spacing = self.slider_of_element_spacing.value()
            if self.current_arrays_combo_box.currentText() in self.arrays:
                old_name = self.current_array.name
                self.current_array.initialize_array_data(name, array_type, number_of_elements, position, frequencies,
                                        self.meshgrid, elements_spacing= elements_spacing, steering_angle= steering_angle)
            else:
                new_array = PhasedArray(name, array_type, number_of_elements, position, frequencies,
                        self.meshgrid, elements_spacing= elements_spacing, steering_angle= steering_angle)
                
        elif self.radio_button_of_curve.isChecked():
            array_type = "Curved"
            arc_angle = self.slider_of_arc_angle.value()
            raduis = int(self.radius_line_edit.text())
            if self.current_arrays_combo_box.currentText() in self.arrays:
                old_name = self.current_array.name
                self.current_array.initialize_array_data(name, array_type, number_of_elements, position, frequencies, self.meshgrid,
                                        steering_angle= steering_angle, raduis = raduis, arc_angle = arc_angle)
            else:
                new_array = PhasedArray(name, array_type, number_of_elements, position, frequencies, self.meshgrid,
                        steering_angle= steering_angle, raduis = raduis, arc_angle = arc_angle)
                       
        if self.current_arrays_combo_box.currentText() in self.arrays:
            self.arrays[name] = self.arrays.pop(old_name)
            self.current_array.calculate_beam_distances(self.beam_profile_x, self.beam_profile_y)
            self.remove_combobox_item(self.current_arrays_combo_box, old_name)
        else:
            new_array.calculate_beam_distances(self.beam_profile_x, self.beam_profile_y)
            self.arrays[name] = new_array

        self.current_arrays_combo_box.addItem(name)
        self.draw_arrays()
        self.animate()

    def add_update_receiver(self):
        name = self.reciver_name.text()
        position = np.array([int(self.reciver_position_x.currentText()), int(self.reciver_position_y.currentText())])
        if self.current_recivers_combo_box.currentText() in self.receivers_:
            old_name = self.current_receiver.name
            self.current_receiver.initialize_receiver_data(name, position)
            self.receivers_[name] = self.receivers_.pop(old_name)
            self.remove_combobox_item(self.current_recivers_combo_box, old_name)
            self.current_recivers_combo_box.addItem(name)
        else:
            new_receiver = Receiver(name, position)
            self.receivers_[name] = new_receiver
            self.current_recivers_combo_box.addItem(name)
        self.draw_receivers()
        self.animate()

    def draw_arrays(self):
        for array in self.arrays.values():
            self.transmiters_recivers_plotter.axes.scatter(
            array.source_positions[:, 0], array.source_positions[:, 1], label=array.name, marker='o'
                         )
            
    def draw_receivers(self):
        receivers_positions = []
        for receiver in self.receivers_.values():
            receivers_positions.append(receiver.position)
            self.receiver_texts = [
                self.transmiters_recivers_plotter.axes.text(receiver.position[0] + 0.1,
                                                        receiver.position[1], "", fontsize=8, color="black")
                        ]
        receiver_markers = self.transmiters_recivers_plotter.axes.scatter(*zip(*receivers_positions),
                                                                      color='red', marker='x', s=100, label="Receivers")
        
    def update_phase_shifts(self, slider_value, slider_index):
        self.clear_layout(self.grid_layout_of_change_info)
        self.phase_shifts_sliders_values[slider_index] = slider_value
        self.current_array.phase_shifts = self.phase_shifts_sliders_values

    def change_current_array(self):
        self.current_array = self.arrays[self.current_arrays_combo_box.currentText()]
        self.grid_layout_of_change_info = self.slider_creator(self, self.current_array.number_of_elements)
        self.array_name_line_edit.setText(self.current_array.name)
        self.slider_of_transmiters_number.setValue(self.current_array.number_of_elements)
        self.array_position_x_line_edit.setText(str(self.current_array.position[0]))
        self.array_position_y_line_edit.setText(str(self.current_array.position[1]))
        self.frequencies_line_edit.setText(str(self.current_array.frequencies))

        if self.current_array.array_type == "Linear":
            self.radio_button_of_linear.setChecked(True)
            self.slider_of_element_spacing.setValue(self.current_array.elements_spacing)
        else:
            self.radio_button_of_curve.setChecked(True)
            self.radius_line_edit.setText(str(self.current_array.raduis))
            self.slider_of_arc_angle.setValue(np.degrees(self.current_array.arc_angle))

    def remove_array(self):
        if self.current_arrays_combo_box.currentText() in self.arrays:
            temp_array = self.arrays[self.current_arrays_combo_box.currentText()]
            del temp_array
            del self.arrays[self.current_arrays_combo_box.currentText()]
        
    def remove_receiver(self):
        if self.current_recivers_combo_box.currentText() in self.receivers_:
            temp_receiver = self.receivers_[self.current_recivers_combo_box.currentText()]
            del temp_receiver
            del self.receivers_[self.current_recivers_combo_box.currentText()]
        
    def change_current_receiver(self):
        self.current_receiver = self.receivers_[self.current_recivers_combo_box.currentText()]
        self.reciver_name.setText(self.current_receiver.name)
        self.reciver_position_x.setText(str(self.current_receiver.position[0]))
        self.reciver_position_y.setText(str(self.current_receiver.position[1]))

    def update(self, frame):
        time = frame / 10.0
        self.beam_profile_power.fill(0)
        resultant_wave = np.zeros_like(self.meshgrid[0])
        beam_profile_amplitude = np.zeros_like(self.beam_profile_x)
        receiver_signals = []

        for array in self.arrays.values():

            for horizontal_displacement, beam_profile_displacement, phase_shift\
                             in zip(array.distances, array.beam_distances, array.phase_shifts):
                
                for frequency, wavelength in zip(array.frequencies, array.wavelengths):
                    wave_number = 2 * np.pi / wavelength
                    omega = 2 * np.pi * frequency
                    resultant_wave += np.sin(wave_number * horizontal_displacement - \
                                             omega * time + phase_shift[array.wavelengths.index(wavelength)])
                    beam_profile_amplitude += np.sin(wave_number * beam_profile_displacement - \
                                                     omega * time + phase_shift[array.wavelengths.index(wavelength)])

            for wavelength in array.wavelengths:
                wave_number = 2 * np.pi / wavelength

                # Compute steering vector and polar intensity
                for theta_idx, theta in enumerate(self.beam_profile_angles):
                    steering_vector = np.exp(1j * wave_number * (
                        array.source_positions[:, 0] * np.cos(theta - array.steering_angle) +
                        array.source_positions[:, 1] * np.sin(theta - array.steering_angle)
                    ))
                    self.beam_profile_power[theta_idx] += np.abs(np.sum(steering_vector))**2

        for receiver in self.receivers_.values():
            signal = 0
            for array in self.arrays.values():
                for horizontal_displacement, phase_shift in zip(array.distances, array.phase_shifts):
                    signal += np.sin(2 * np.pi * np.linalg.norm(receiver) - omega * time + phase_shift[0])
            receiver_signals.append(signal)

        for idx, text in enumerate(self.receiver_texts):
            text.set_text(f"{receiver_signals[idx]:.2f}")

        # Update plots
        for c in self.heat_map.axes.collections:
            c.remove()
        self.heat_map.axes.contourf(self.meshgrid[0], self.meshgrid[1], resultant_wave, levels=100, cmap='RdBu')

        # Normalize polar power and convert to dB
        polar_power_db = 10 * np.log10(self.beam_profile_power / np.max(self.beam_profile_power) + 1e-12)

        # Update polar plot
        self.beam_profile.axes.clear()
        self.beam_profile.axes.plot(self.beam_profile_angles - np.pi /2, polar_power_db, label="Beam Pattern")
        self.beam_profile.axes.set_theta_zero_location("N")
        self.beam_profile.axes.set_theta_direction(-1)  # Clockwise
        # ax_polar.plot(angles + np.pi / 2, polar_power_db)  # Add Ï€/2 to rotate
        self.beam_profile.axes.legend()

    def animate(self):
        ani = FuncAnimation(self.heat_map.fig, self.update, frames=100, interval=50)
        ani2 = FuncAnimation(self.beam_profile.fig, self.update, frames=100, interval=50)
        ani3 = FuncAnimation(self.transmiters_recivers_plotter.fig, self.update, frames=100, interval=50)
        self.beam_profile.fig.tight_layout()
        self.beam_profile.draw()
        self.heat_map.fig.tight_layout()
        self.heat_map.draw()
        self.transmiters_recivers_plotter.fig.tight_layout()
        self.transmiters_recivers_plotter.draw()

if __name__ == "__main__":

    app = QApplication(sys.argv)
    apply_stylesheet(app, "dark_purple.xml")
    window = Main()
    window.show()
    sys.exit(app.exec_())