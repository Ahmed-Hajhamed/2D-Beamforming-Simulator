import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Constants
c = 2270  # Speed of light in m/s (for delay calculation)
frequency = 1.0  # Example frequency in Hz

# Parameters for multiple phased array units
phased_arrays = [
    {
        "type": "linear",  # "linear" or "curved"
        "num_elements": 7,
        "element_spacing": 0.5,  # Relative to wavelength of first frequency
        "frequencies": [1.0, 1.25],
        "wavelengths": [1.0, 0.8],  # Corresponding to frequencies
        "steering_angle": 30,  # Degrees
        "position": [0, 0],  # Center of the array
    },
    {
        "type": "curved",
        "num_elements": 5,
        "frequencies": [0.8, 1.2],
        "wavelengths": [1.25, 1.0],
        "steering_angle": -15,
        "position": [1.5, 1.0],
        "radius": 1.0,
        "arc_angle": 120,  # Degrees
    }
]

# Define grid for visualization
x = np.linspace(-3, 3, 500)
y = np.linspace(-3, 3, 500)
X, Y = np.meshgrid(x, y)

# Precompute distances and phase shifts for each array
arrays_data = []
for array in phased_arrays:
    num_elements = array["num_elements"]
    wavelengths = array["wavelengths"]
    frequencies = array["frequencies"]
    steering_angle = np.radians(array["steering_angle"])
    center_x, center_y = array["position"]

    # Calculate source positions based on array type
    if array["type"] == "linear":
        element_spacing = array["element_spacing"] * wavelengths[0]
        source_positions = [
            np.array([i * element_spacing - (num_elements - 1) * element_spacing / 2, 0])
            for i in range(num_elements)
        ]
    elif array["type"] == "curved":
        arc_angle = np.radians(array["arc_angle"])
        radius = array["radius"]
        angles = np.linspace(-arc_angle / 2, arc_angle / 2, num_elements)
        source_positions = [
            np.array([radius * np.sin(angle), radius * np.cos(angle)]) for angle in angles
        ]

    # Offset by array center
    source_positions = [pos + np.array([center_x, center_y]) for pos in source_positions]
    arrays_data.append({"positions": source_positions, "frequencies": frequencies, "wavelengths": wavelengths})

# Receiver positions
receivers = [(-1, 1), (1, -1), (-2, 2), (2, -2)]

# Define angular range for polar plot
angles = np.linspace(-np.pi / 2, np.pi / 2, 360)  # Radians
steering_vector = np.array([np.sin(angles), np.cos(angles)])

# Initialize plot
fig, (ax_wave, ax_arrays, ax_beam) = plt.subplots(1, 3, figsize=(18, 6))

# Configure wave plot
contour = ax_wave.contourf(X, Y, np.zeros_like(X), levels=100, cmap='RdBu')
plt.colorbar(contour, ax=ax_wave, label='Amplitude')

ax_wave.set_title("Wave Field Visualization")
ax_wave.set_xlabel("X Position (wavelengths)")
ax_wave.set_ylabel("Y Position (wavelengths)")
ax_wave.axis('equal')

# Configure array and receiver plot
for idx, array_data in enumerate(arrays_data):
    positions = np.array(array_data["positions"])
    ax_arrays.scatter(
        positions[:, 0], positions[:, 1], label=f"Array {idx+1}", marker='o'
    )

receiver_markers = ax_arrays.scatter(*zip(*receivers), color='red', marker='x', s=100, label="Receivers")
receiver_texts = [
    ax_arrays.text(rx[0] + 0.1, rx[1], "", fontsize=8, color="black") for rx in receivers
]

ax_arrays.set_title("Array Elements and Receivers")
ax_arrays.set_xlabel("X Position (wavelengths)")
ax_arrays.set_ylabel("Y Position (wavelengths)")
ax_arrays.legend()
ax_arrays.grid(True)
ax_arrays.axis('equal')

# Configure beam profile plot (polar plot)
ax_beam = plt.subplot(133, polar=True)  # Create a polar subplot
beam_line, = ax_beam.plot(angles, np.zeros_like(angles), label="Beam Pattern")
ax_beam.set_title("Polar Beam Pattern")
ax_beam.set_xlabel("Angle (radians)")
ax_beam.set_ylabel("Normalized Intensity")

# Configure polar plot properties without using unsupported methods
ax_beam.set_theta_offset(np.pi / 2)  # Move the zero angle to the top
ax_beam.set_theta_direction(-1)  # Clockwise angle direction
ax_beam.set_rlabel_position(90)  # Radial labels at 90Â°
ax_beam.grid(True)
ax_beam.legend()

# Animation function
def update(frame):
    global c  # Ensure c is recognized inside the function
    time = frame / 10.0
    resultant_wave = np.zeros_like(X)
    beam_profile_amplitude = np.zeros_like(angles)
    receiver_signals = []

    for array_data in arrays_data:
        positions = array_data["positions"]
        frequencies = array_data["frequencies"]
        wavelengths = array_data["wavelengths"]
        
        # Array Factor Calculation
        array_factor = np.zeros_like(angles, dtype=np.complex128)
        for (x, y) in positions:
            delays = np.dot(np.array([x, y]), steering_vector) / c  # Time delay for each angle
            phase_shifts = -2 * np.pi * frequencies[0] * delays
            array_factor += np.exp(1j * phase_shifts)

        # Normalize the array factor
        normalized_af = np.abs(array_factor) / np.max(np.abs(array_factor))
        beam_profile_amplitude += normalized_af  # Add to the total beam pattern

        # Receiver Signal Calculation (simplified)
        for rx in receivers:
            signal = 0
            for (x, y) in positions:
                distance = np.sqrt((rx[0] - x)**2 + (rx[1] - y)**2)
                signal += np.sin(2 * np.pi * frequency * distance / c - 2 * np.pi * frequency * time)
            receiver_signals.append(signal)

    # Update receiver text
    for i, text in enumerate(receiver_texts):
        text.set_text(f"{receiver_signals[i]:.2f}")

    # Update plots
    for c in ax_wave.collections:
        c.remove()
    ax_wave.contourf(X, Y, resultant_wave, levels=100, cmap='RdBu')
    beam_line.set_ydata(beam_profile_amplitude)

# Create animation
ani = FuncAnimation(fig, update, frames=100, interval=50)
plt.tight_layout()
plt.show()
