import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Parameters for multiple phased array units
phased_arrays = [
    {
        "type": "linear",  # "linear" or "curved"
        "num_elements": 7,
        "element_spacing": 0.5,  # Relative to wavelength of first frequency
        "frequencies": [1.0, 1.25],
        "wavelengths": [1.0, 0.8],  # Corresponding to frequencies
        "steering_angle": 30,  # Degrees
        "position": [0, 0],  # Center of the array
        "radius": None,  # Only for curved arrays
        "arc_angle": None,  # Only for curved arrays
    },
    {
        "type": "curved",
        "num_elements": 5,
        "element_spacing": None,  # Not used for curved arrays
        "frequencies": [0.8, 1.2],
        "wavelengths": [1.25, 1.0],
        "steering_angle": -15,  # Degrees
        "position": [1.5, 1.0],  # Center of the array
        "radius": 1.0,
        "arc_angle": 120,  # Degrees
    }
]

# Receiver positions
receivers = [
    [0.5, 0.5],
    [-1.0, -1.5],
    [2.0, 1.0],
    [0.0, 2.0]
]

# Define grid for visualization
x = np.linspace(-3, 3, 500)  # X-axis (horizontal distance)
y = np.linspace(-3, 3, 500)  # Y-axis (vertical distance)
X, Y = np.meshgrid(x, y)  # Create a 2D grid

# Calculate distances and phase shifts for each array
arrays_data = []
for array in phased_arrays:
    num_elements = array["num_elements"]
    wavelengths = array["wavelengths"]
    frequencies = array["frequencies"]
    steering_angle = np.radians(array["steering_angle"])  # Convert to radians
    center_x, center_y = array["position"]
    
    # Calculate source positions
    if array["type"] == "linear":
        element_spacing = array["element_spacing"] * wavelengths[0]
        source_positions = [
            np.array([i * element_spacing - (num_elements - 1) * element_spacing / 2, 0])
            for i in range(num_elements)
        ]
    elif array["type"] == "curved":
        arc_angle = np.radians(array["arc_angle"])
        radius = array["radius"]
        angles = np.linspace(-arc_angle / 2, arc_angle / 2, num_elements)
        source_positions = [
            np.array([radius * np.sin(angle), radius * np.cos(angle)]) for angle in angles
        ]
    
    # Offset by array center
    source_positions = [pos + np.array([center_x, center_y]) for pos in source_positions]
    
    # Calculate distances and phase shifts
    distances = [
        np.sqrt((X - pos[0])**2 + (Y - pos[1])**2)
        for pos in source_positions
    ]
    phase_shifts = [
        [
            2 * np.pi / wavelength * pos[0] * np.sin(steering_angle)
            + 2 * np.pi / wavelength * pos[1] * np.cos(steering_angle)
            for wavelength in wavelengths
        ]
        for pos in source_positions
    ]
    
    # Store array data
    arrays_data.append({
        "positions": source_positions,
        "distances": distances,
        "phase_shifts": phase_shifts,
        "wavelengths": wavelengths,
        "frequencies": frequencies
    })

# Initialize plot
fig, ax = plt.subplots(figsize=(8, 6))
contour = ax.contourf(X, Y, np.zeros_like(X), levels=100, cmap='RdBu')  # Placeholder for the wave
plt.colorbar(contour, ax=ax, label='Amplitude')

# Plot source positions for each array
for array_data in arrays_data:
    for pos in array_data["positions"]:
        ax.scatter(*pos, color='black', marker='o')  # Mark source positions

# Plot receiver positions and store them for later updates
receiver_markers = []
receiver_texts = []  # For displaying signal strengths
for rx in receivers:
    marker = ax.scatter(*rx, color='green', marker='x', s=100, label="Receiver")
    receiver_markers.append(marker)
    text = ax.text(rx[0] + 0.1, rx[1], "0", fontsize=9, color='black')  # Initial text for signal strength
    receiver_texts.append(text)

ax.set_title("Phased Arrays with Receivers")
ax.set_xlabel("X Position (wavelengths)")
ax.set_ylabel("Y Position (wavelengths)")
ax.axis('equal')

# Animation function
def update(frame):
    time = frame / 10.0  # Increment time
    resultant_wave = np.zeros_like(X)  # Initialize resultant wave
    
    # Compute wave contributions from all arrays
    for array_data in arrays_data:
        wavelengths = array_data["wavelengths"]
        frequencies = array_data["frequencies"]
        distances = array_data["distances"]
        phase_shifts = array_data["phase_shifts"]
        
        for freq, wavelength in zip(frequencies, wavelengths):
            k = 2 * np.pi / wavelength  # Wave number
            omega = 2 * np.pi * freq  # Angular frequency
            
            for r, phi in zip(distances, phase_shifts):
                resultant_wave += np.sin(k * r - omega * time + phi[wavelengths.index(wavelength)])
    
    # Update the contour plot
    for c in ax.collections:
        c.remove()
    ax.contourf(X, Y, resultant_wave, levels=100, cmap='RdBu')
    
    # Update received signals for each receiver
    for i, rx in enumerate(receivers):
        signal = 0
        for array_data in arrays_data:
            for pos, wavelengths, frequencies in zip(
                array_data["positions"],
                array_data["wavelengths"],
                array_data["frequencies"]
            ):
                distance = np.sqrt((rx[0] - pos[0])**2 + (rx[1] - pos[1])**2)
                k = 2 * np.pi / wavelengths  # Wave number
                omega = 2 * np.pi * frequencies
                signal += np.sin(k * distance - omega * time)
        
        # Normalize the signal strength for marker size adjustment
        normalized_signal = (signal + 2) / 4  # Normalize to range [0, 1]
        receiver_markers[i].set_sizes([normalized_signal * 300])  # Size varies with signal
        
        # Update the text to show the signal strength
        receiver_texts[i].set_text(f"{signal:.2f}")  # Display numerical value of the signal
        receiver_texts[i].set_position((rx[0] + 0.1, rx[1]))  # Ensure text stays near the receiver marker

# Start animation
# update(0)
ani = FuncAnimation(fig, update, frames=100, interval=50)  # 100 frames, 50ms interval
plt.show()
