import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Parameters for multiple phased array units
phased_arrays = [
    {
        "type": "linear",
        "num_elements": 7,
        "element_spacing": 0.5,
        "frequencies": [1.0, 1.25],
        "wavelengths": [1.0, 0.8],
        "steering_angle": 30,  # Degrees
        "position": [0, 0],
    }
    ,
    {
        "type": "curved",
        "num_elements": 5,
        "frequencies": [0.8, 1.2],
        "wavelengths": [1.25, 1.0],
        "steering_angle": -90,
        "position": [1.5, 1.0],
        "radius": 1.0,
        "arc_angle": 120,  # Degrees
    }
]

# Receiver positions
receivers = [(-1, 1), (1, -1), (-2, 2), (2, -2)]

# Define grid for visualization
x = np.linspace(-20, 20, 200)
y = np.linspace(-20, 20, 200)
X, Y = np.meshgrid(x, y)

# Precompute distances and phase shifts for each array
arrays_data = []
for array in phased_arrays:
    num_elements = array["num_elements"]
    wavelengths = array["wavelengths"]
    frequencies = array["frequencies"]
    steering_angle = np.radians(array["steering_angle"])
    center_x, center_y = array["position"]

    if array["type"] == "linear":
        element_spacing = array["element_spacing"] * wavelengths[0]
        source_positions = [
            np.array([i * element_spacing - (num_elements - 1) * element_spacing / 2, 0])
            for i in range(num_elements)
        ]
    elif array["type"] == "curved":
        arc_angle = np.radians(array["arc_angle"])
        radius = array["radius"]
        angles = np.linspace(-arc_angle / 2, arc_angle / 2, num_elements)
        source_positions = [
            np.array([radius * np.sin(angle), radius * np.cos(angle)]) for angle in angles
        ]
    source_positions = [pos + np.array([center_x, center_y]) for pos in source_positions]

    distances = [
        np.sqrt((X - pos[0])**2 + (Y - pos[1])**2) for pos in source_positions
    ]
    
    # Phase shift calculation
    phase_shifts = [
        [
            2 * np.pi / wavelength * pos[0] * np.sin(steering_angle)
            + 2 * np.pi / wavelength * pos[1] * np.cos(steering_angle)
            for wavelength in wavelengths
        ]
        for pos in source_positions
    ]
    
    arrays_data.append({
        "positions": source_positions,
        "distances": distances,
        "phase_shifts": phase_shifts,
        "frequencies": frequencies,
        "wavelengths": wavelengths,
    })

# Initialize plot
fig, (ax_wave, ax_arrays) = plt.subplots(1, 2, figsize=(18, 6))
ax_polar = fig.add_subplot(133, projection='polar')  # Polar plot for beam profile

# Configure wave plot
contour = ax_wave.contourf(X, Y, np.zeros_like(X), levels=100, cmap='RdBu')
plt.colorbar(contour, ax=ax_wave, label='Amplitude')

ax_wave.set_title("Wave Field Visualization")
ax_wave.set_xlabel("X Position (wavelengths)")
ax_wave.set_ylabel("Y Position (wavelengths)")
ax_wave.axis('equal')

# Configure array and receiver plot
for idx, array_data in enumerate(arrays_data):
    positions = np.array(array_data["positions"])
    ax_arrays.scatter(
        positions[:, 0], positions[:, 1], label=f"Array {idx+1}", marker='o'
    )

receiver_markers = ax_arrays.scatter(*zip(*receivers), color='red', marker='x', s=100, label="Receivers")
receiver_texts = [
    ax_arrays.text(rx[0] + 0.1, rx[1], "", fontsize=8, color="black") for rx in receivers
]

ax_arrays.set_title("Array Elements and Receivers")
ax_arrays.set_xlabel("X Position (wavelengths)")
ax_arrays.set_ylabel("Y Position (wavelengths)")
ax_arrays.legend()
ax_arrays.grid(True)
ax_arrays.axis('equal')

# Configure polar beam plot
ax_polar.set_title("Beam Profile (Polar)")
ax_polar.set_theta_zero_location("N")
ax_polar.set_theta_direction(-1)

# Animation function
def update(frame):
    time = frame / 10.0
    resultant_wave = np.zeros_like(X)
    beam_profile_amplitude = np.zeros(500)  # Beam profile along angles
    receiver_signals = []

    # Compute beam profile for polar plot
    theta_vals = np.linspace(-np.pi/2, np.pi/2, 500)  # Angle range for polar plot
    for array_data in arrays_data:
        distances = array_data["distances"]
        phase_shifts = array_data["phase_shifts"]
        frequencies = array_data["frequencies"]
        wavelengths = array_data["wavelengths"]

        for r, phi in zip(distances, phase_shifts):
            for freq, wavelength in zip(frequencies, wavelengths):
                k = 2 * np.pi / wavelength
                omega = 2 * np.pi * freq
                beam_profile_amplitude += np.sin(k * r - omega * time + phi[0])

    # Update the beam profile plot (polar)
    ax_polar.clear()
    ax_polar.plot(theta_vals, beam_profile_amplitude, label="Beam Profile")
    ax_polar.legend()

    # Update wave field plot
    for c in ax_wave.collections:
        c.remove()
    ax_wave.contourf(X, Y, resultant_wave, levels=100, cmap='RdBu')

    # Update receiver signals
    for rx in receivers:
        signal = 0
        for array_data in arrays_data:
            for r, phi in zip(array_data["distances"], array_data["phase_shifts"]):
                signal += np.sin(2 * np.pi * np.linalg.norm(rx) - omega * time + phi[0])
        receiver_signals.append(signal)

    for i, text in enumerate(receiver_texts):
        text.set_text(f"{receiver_signals[i]:.2f}")

# Create animation
ani = FuncAnimation(fig, update, frames=100, interval=50)
plt.tight_layout()
plt.show()
