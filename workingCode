import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Parameters for multiple phased array units
phased_arrays = [
    {
        "type": "linear",
        "num_elements": 7,
        "element_spacing": 0.5,
        "frequencies": [1.0, 1.25],
        "wavelengths": [1.0, 0.8],
        "steering_angle": -30,  # Degrees
        "position": [0, 0],
    }
    ,
    {
        "type": "curved",
        "num_elements": 16,
        "frequencies": [0.8, 1.2],
        "wavelengths": [1.25, 1.0],
        "steering_angle": -60,
        "position": [1.5, 1.0],
        "radius": 1.0,
        "arc_angle": 120,  # Degrees
    }
]
# Receiver positions
receivers = [(-1, 1), (1, -1), (-2, 2), (2, -2)]

# Define grid for visualization
x = np.linspace(-20, 20, 200)
y = np.linspace( -20, 20, 200)
X, Y = np.meshgrid(x, y)

# Define beam profile line (along X-axis for simplicity)
beam_profile_x = np.linspace(-20, 20, 500)
beam_profile_y = np.zeros_like(beam_profile_x)

# Precompute positions and parameters for each array
arrays_data = []
for array in phased_arrays:
    num_elements = array["num_elements"]
    wavelengths = array["wavelengths"]
    frequencies = array["frequencies"]
    steering_angle = np.radians(array["steering_angle"])
    center_x, center_y = array["position"]

    if array["type"] == "linear":
        element_spacing = array["element_spacing"] * wavelengths[0]
        source_positions = [
            np.array([i * element_spacing - (num_elements - 1) * element_spacing / 2, 0])
            for i in range(num_elements)
        ]
    elif array["type"] == "curved":
        arc_angle = np.radians(array["arc_angle"])
        radius = array["radius"]
        angles = np.linspace(-arc_angle / 2, arc_angle / 2, num_elements)
        source_positions = [
            np.array([radius * np.sin(angle), radius * np.cos(angle)]) for angle in angles
        ]

    source_positions = [pos + np.array([center_x, center_y]) for pos in source_positions]
    distances = [
        np.sqrt((X - pos[0])**2 + (Y - pos[1])**2) for pos in source_positions
    ]
    beam_distances = [
        np.sqrt((beam_profile_x - pos[0])**2 + (beam_profile_y - pos[1])**2)
        for pos in source_positions
    ]
    phase_shifts = [
        [
            2 * np.pi / wavelength * pos[0] * np.sin(steering_angle)
            + 2 * np.pi / wavelength * pos[1] * np.cos(steering_angle)
            for wavelength in wavelengths
        ]
        for pos in source_positions
    ]
    arrays_data.append({
        "positions": np.array(source_positions),
        "distances": distances,
        "beam_distances": beam_distances,
        "phase_shifts": phase_shifts,
        "frequencies": frequencies,
        "wavelengths": wavelengths,
        "steering_angle": steering_angle,
    })

# Initialize plot
# fig, (ax_wave, ax_arrays,  ax_polar) = plt.subplots(1, 3, figsize=(14, 6), subplot_kw={1: {"projection": "polar"}})
fig = plt.figure(figsize=(18, 6))
ax_wave = fig.add_subplot(131)  # Wave Field Visualization
ax_arrays = fig.add_subplot(132)  # Array Geometry Visualization
ax_polar = fig.add_subplot(133, projection='polar')  # Polar Plot for Beam Profile

# Configure wave plot
ax_wave.set_title("Wave Field Visualization")
ax_wave.set_xlabel("X Position (wavelengths)")
ax_wave.set_ylabel("Y Position (wavelengths)")
ax_wave.axis('equal')

# Configure polar plot
ax_polar.set_title("Polar Beam Pattern", va='bottom')
ax_polar.set_ylim([-40, 0])  # Decibel range
# ax_polar.set_theta_zero_location("N")  # Set 0° to face upwards (North)
# ax_polar.set_theta_direction(-1)       # Set angle direction to clockwise
# ax_polar.set_theta_offset(np.pi/2)
# Configure array and receiver plot
for idx, array_data in enumerate(arrays_data):
    positions = np.array(array_data["positions"])
    ax_arrays.scatter(
        positions[:, 0], positions[:, 1], label=f"Array {idx+1}", marker='o'
    )

receiver_markers = ax_arrays.scatter(*zip(*receivers), color='red', marker='x', s=100, label="Receivers")
receiver_texts = [
    ax_arrays.text(rx[0] + 0.1, rx[1], "", fontsize=8, color="black") for rx in receivers
]

ax_arrays.set_title("Array Elements and Receivers")
ax_arrays.set_xlabel("X Position (wavelengths)")
ax_arrays.set_ylabel("Y Position (wavelengths)")
ax_arrays.legend()
ax_arrays.grid(True)
ax_arrays.axis('equal')

# Initialize variables for polar plot
angles = np.linspace(0, 2 * np.pi, 360)
polar_power = np.zeros_like(angles)

# Animation function
def update(frame):
    global polar_power
    time = frame / 10.0
    polar_power.fill(0)
    resultant_wave = np.zeros_like(X)
    beam_profile_amplitude = np.zeros_like(beam_profile_x)
    receiver_signals = []

    for array_data in arrays_data:
        positions = array_data["positions"]
        distances = array_data["distances"]
        beam_distances = array_data["beam_distances"]
        phase_shifts = array_data["phase_shifts"]
        frequencies = array_data["frequencies"]
        wavelengths = array_data["wavelengths"]
        steering_angle = array_data["steering_angle"]

        for r, beam_r, phi in zip(distances, beam_distances, phase_shifts):
            for freq, wavelength in zip(frequencies, wavelengths):
                k = 2 * np.pi / wavelength
                omega = 2 * np.pi * freq
                resultant_wave += np.sin(k * r - omega * time + phi[wavelengths.index(wavelength)])
                beam_profile_amplitude += np.sin(k * beam_r - omega * time + phi[wavelengths.index(wavelength)])

        for wavelength in wavelengths:
            k = 2 * np.pi / wavelength

            # Compute steering vector and polar intensity
            for theta_idx, theta in enumerate(angles):
                steering_vector = np.exp(1j * k * (
                    positions[:, 0] * np.cos(theta - steering_angle) +
                    positions[:, 1] * np.sin(theta - steering_angle)
                ))
                polar_power[theta_idx] += np.abs(np.sum(steering_vector))**2
    for rx in receivers:
        signal = 0
        for array_data in arrays_data:
            for r, phi in zip(array_data["distances"], array_data["phase_shifts"]):
                signal += np.sin(2 * np.pi * np.linalg.norm(rx) - omega * time + phi[0])
        receiver_signals.append(signal)

    for i, text in enumerate(receiver_texts):
        text.set_text(f"{receiver_signals[i]:.2f}")

    # Update plots
    for c in ax_wave.collections:
        c.remove()
    ax_wave.contourf(X, Y, resultant_wave, levels=100, cmap='RdBu')

    # Normalize polar power and convert to dB
    polar_power_db = 10 * np.log10(polar_power / np.max(polar_power) + 1e-12)

    # Update polar plot
    ax_polar.clear()
    ax_polar.plot(angles - np.pi /2, polar_power_db, label="Beam Pattern")
    ax_polar.set_theta_zero_location("N")
    ax_polar.set_theta_direction(-1)  # Clockwise
    # ax_polar.plot(angles + np.pi / 2, polar_power_db)  # Add π/2 to rotate
    ax_polar.legend()

    # ///////////////////////////////////////////////////////////////////////////////////////////////////////////
    # Configure wave plot (Crop to show only upward emission)
    # ax_wave.set_ylim(0, 20)  # Show only the top half (positive Y)
    # ax_wave.set_xlim(-20, 20)  # Maintain full X range
    # ax_wave.set_title("Wave Field Visualization")
    # ax_wave.set_xlabel("X Position (wavelengths)")
    # ax_wave.set_ylabel("Y Position (wavelengths)")
    # ax_wave.axis('equal')

    # # Configure polar plot (Crop to show only upward emission)
    # ax_polar.set_title("Polar Beam Pattern (Upwards Only)", va='bottom')
    # ax_polar.set_ylim(-40, 0)  # Decibel range
    # ax_polar.set_theta_zero_location("N")  # Set 0° to face upwards (North)
    # ax_polar.set_theta_direction(-1)       # Set angle direction to clockwise
    # # ax_polar.set_theta_offset(np.pi / 2)   # Rotate so 0° is at the top
    # ax_polar.set_thetamin(-90)               # Show angles from 0° to 180° (upwards)
    # ax_polar.set_thetamax(90)


# Create animation
ani = FuncAnimation(fig, update, frames=100, interval=50)
plt.tight_layout()
plt.show()
